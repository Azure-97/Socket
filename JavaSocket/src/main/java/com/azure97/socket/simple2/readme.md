## 第二例：Socket实现客户端与服务器端通信
在第一个例子中，只是实现了客户端向服务器发送信息，但服务器并没有对客户端进行信息回复。
所以第二个例子实现双向通信的。为了简化代码，提高可读性，接下来的例子我将不再进行资源的关闭回收。

第二个例子可以非常好的体现出面向连接的Socket发送的数据在另一端会以相同的顺序被接收这个特点。接下来，我们来分析下代码逻辑。

首先我们先启动服务器，然后启动客户端，这时服务器会走到等待客户端发送socket中输入流的步骤（in.readLine()），客户端会走到等待控制台中输入流的步骤（out.readLine()）。

然后因为客户端在等待控制台输入，服务器在等待客户端发送信息，所以我们先在客户端的控制台输入一串字符，这时，客户端就会在控制台打印输出这串字符，然后走到等待服务器发送socket中输入流的步骤（in.readLine()），服务器就会收到这串输入流，然后在控制台打印输出这串输入流，然后走到等待控制台中输入流的步骤（out.readLine()）。

之后再服务器端的控制台输入一串字符，又会进入下一个循环的等待。

这个例子的逻辑是客户端先发送一次通信，服务器接收通信并发送一次通信，客户端再接收并发送一次通信。之前也说了，由于面向连接的Socket发送的数据在另一端会以相同的顺序被接收，所以，如果你在客户端连续发送了两次通信，那么服务器一个循环只会接收一次通信，然后服务器再次发送一次通信后，才会接收到客户端的第二次通信。理由是下面的readline已经读到数据可以继续执行了，但上面的readline还没有读到数据，程序在这就已经阻塞了。

这个特点会导致一个现象，就是客户端发送几十几百次消息，但服务器只接收到了第一个消息。其实是剩下的消息还没有进行读取而已。

以上两个例子是为了帮助你更好的理解Socket应该怎么使用，但是只是一对一的通信，而且是服务器对客户端的一对一通信，那么多个客户端怎么连接服务器呢？客户端和客户端之间怎么通信呢？这就是Socket的聊天室功能了。